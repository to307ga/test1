AWSTemplateFormatVersion: '2010-09-09'
Description: 'Clean DKIM Manager Lambda function - AWS Official OpenSSL Implementation'

Parameters:
  ProjectName:
    Type: String
    Description: Project name for resource naming
    Default: aws-ses-migration

  Environment:
    Type: String
    Description: Environment name
    AllowedValues:
      - dev
      - staging
      - prod
    Default: prod

  DKIMManagerRoleArn:
    Type: String
    Description: ARN of the DKIM Manager Lambda execution role

  DKIMConfigSecretArn:
    Type: String
    Description: ARN of the DKIM configuration secret

  DKIMCertificatesBucketName:
    Type: String
    Description: Name of the S3 bucket for DKIM certificates

  LambdaRuntime:
    Type: String
    Description: Lambda function runtime
    Default: "python3.13"

  DKIMEncryptionKeyArn:
    Type: String
    Description: ARN of the KMS encryption key

  CertificateValidityDays:
    Type: Number
    Description: Certificate validity period in days
    Default: 365

  RenewalAlertDays:
    Type: Number
    Description: Days before expiration to send renewal alerts
    Default: 30

  DKIMSeparator:
    Type: String
    Description: DKIM selector separator for generating selectors (e.g., gooid-21-pro, gooid-21-dev)

  BYODKIMAutoApplyToSES:
    Type: String
    Description: Auto-apply new DKIM keys to SES (false for manual control)
    Default: "false"
    AllowedValues: ["true", "false"]

  BYODKIMRotationMode:
    Type: String
    Description: BYODKIM rotation mode for DNS coordination safety
    Default: "MANUAL"
    AllowedValues: ["MANUAL", "AUTOMATED"]

  DNSTeamNotificationEmail:
    Type: String
    Description: Email for DNS team notifications
    Default: ""

Resources:
  DKIMManagerFunctionV2:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${ProjectName}-${Environment}-dkim-manager-v2"
      Runtime: !Ref LambdaRuntime
      Handler: index.lambda_handler
      Role: !Ref DKIMManagerRoleArn
      Timeout: 300
      MemorySize: 512
      Environment:
        Variables:
          DKIM_CONFIG_SECRET_ARN: !Ref DKIMConfigSecretArn
          CERTIFICATES_BUCKET_NAME: !Ref DKIMCertificatesBucketName
          KMS_KEY_ARN: !Ref DKIMEncryptionKeyArn
          ENVIRONMENT: !Ref Environment
          PROJECT_NAME: !Ref ProjectName
          CERTIFICATE_VALIDITY_DAYS: !Ref CertificateValidityDays
          RENEWAL_ALERT_DAYS: !Ref RenewalAlertDays
          DKIM_SEPARATOR: !Ref DKIMSeparator
          BYODKIM_AUTO_APPLY_TO_SES: !Ref BYODKIMAutoApplyToSES
          BYODKIM_ROTATION_MODE: !Ref BYODKIMRotationMode
          DNS_TEAM_NOTIFICATION_EMAIL: !Ref DNSTeamNotificationEmail
      Code:
        ZipFile: |
          import json
          import boto3
          import logging
          import os
          import subprocess
          import tempfile
          import base64
          from datetime import datetime, timedelta
          from botocore.exceptions import ClientError

          # Configure logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          # AWS clients
          s3_client = boto3.client('s3')
          secrets_client = boto3.client('secretsmanager')
          sesv2_client = boto3.client('sesv2')

          def lambda_handler(event, context):
              """
              AWS Official BYODKIM Implementation with Phase 8 Integration
              Based on: https://docs.aws.amazon.com/ses/latest/dg/send-email-authentication-dkim-bring-your-own.html
              """
              try:
                  logger.info(f"DKIM Manager V2 invoked with event: {json.dumps(event, indent=2)}")

                  # Handle SNS notification from Phase 8 Monitoring
                  if 'Records' in event and event['Records']:
                      for record in event['Records']:
                          if record.get('EventSource') == 'aws:sns':
                              # Parse SNS message
                              sns_message = json.loads(record['Sns']['Message'])
                              logger.info(f"Received SNS alert from Phase 8: {json.dumps(sns_message, indent=2)}")

                              if sns_message.get('alert_type') == 'certificate_expiring':
                                  # Check rotation mode before automatic execution
                                  rotation_mode = os.environ.get('BYODKIM_ROTATION_MODE', 'MANUAL')

                                  if rotation_mode == 'MANUAL':
                                      logger.info("Certificate expiring alert received - MANUAL mode: generating new key WITHOUT applying to SES")

                                      # Execute certificate generation WITHOUT applying to SES
                                      renewal_event = {
                                          'action': 'create_dkim_certificate_prepare_only',
                                          'domain': sns_message.get('domain', 'goo.ne.jp'),
                                          'environment': sns_message.get('environment', 'prod'),
                                          'project_name': sns_message.get('project_name', 'aws-ses-migration'),
                                          'triggered_by': 'phase8_monitoring',
                                          'apply_to_ses': False  # Key generation only, no SES application
                                      }

                                      result = create_dkim_certificate_prepare_only(renewal_event)

                                      # Send DNS team notification
                                      dns_email = os.environ.get('DNS_TEAM_NOTIFICATION_EMAIL')
                                      if dns_email:
                                          send_dns_team_notification(renewal_event, result, dns_email)
                                  else:
                                      logger.info("Certificate expiring alert received - AUTOMATED mode: starting automatic renewal")

                                      # Execute certificate generation with current domain and settings
                                      renewal_event = {
                                          'action': 'create_dkim_certificate',
                                          'domain': sns_message.get('domain', 'goo.ne.jp'),
                                          'environment': sns_message.get('environment', 'prod'),
                                          'project_name': sns_message.get('project_name', 'aws-ses-migration'),
                                          'triggered_by': 'phase8_monitoring'
                                      }

                                      result = create_dkim_certificate_aws_official(renewal_event)

                                  return {
                                      'statusCode': 200,
                                      'body': json.dumps({
                                          'message': 'Certificate renewal triggered by Phase 8 alert',
                                          'sns_message': sns_message,
                                          'renewal_result': result
                                      })
                                  }

                  # Handle regular Lambda invocation
                  action = event.get('action', 'create_dkim_certificate')

                  if action == 'create_dkim_certificate':
                      return create_dkim_certificate_aws_official(event)
                  elif action == 'create_dkim_certificate_prepare_only':
                      return create_dkim_certificate_prepare_only(event)
                  elif action == 'test_openssl':
                      return test_openssl_availability()
                  elif action == 'update_ses_byodkim_automated':
                      return update_ses_byodkim_automated(event)
                  else:
                      raise ValueError(f"Unsupported action: {action}")

              except Exception as e:
                  logger.error(f"Lambda handler error: {str(e)}")
                  raise

          def test_openssl_availability():
              """Test if OpenSSL is available in Lambda environment"""
              try:
                  # Test OpenSSL availability
                  result = subprocess.run(['openssl', 'version'],
                                        capture_output=True, text=True, check=True)

                  logger.info(f"OpenSSL version: {result.stdout.strip()}")

                  return {
                      'statusCode': 200,
                      'message': 'OpenSSL is available',
                      'openssl_version': result.stdout.strip()
                  }

              except Exception as e:
                  logger.error(f"OpenSSL test failed: {str(e)}")
                  raise

          def create_rsa_key_pair_aws_official(selector):
              """
              AWS Official BYODKIM RSA Key Generation
              Based on: https://docs.aws.amazon.com/ses/latest/dg/send-email-authentication-dkim-bring-your-own.html

              Step 1: openssl genrsa -f4 -out private.key 2048
              Step 2: openssl rsa -in private.key -outform PEM -pubout -out public.key
              """
              try:
                  with tempfile.TemporaryDirectory() as tmpdir:
                      private_key_path = os.path.join(tmpdir, f'private_{selector}.pem')
                      public_key_path = os.path.join(tmpdir, f'public_{selector}.pem')

                      # AWS Official Step 1: Generate 2048-bit RSA private key
                      # Command: openssl genrsa -f4 -out private.key 2048
                      subprocess.run([
                          'openssl', 'genrsa',
                          '-f4',
                          '-out', private_key_path,
                          '2048'
                      ], check=True, capture_output=True, text=True)

                      logger.info(f"Generated RSA private key for selector: {selector}")

                      # AWS Official Step 2: Extract public key
                      # Command: openssl rsa -in private.key -outform PEM -pubout -out public.key
                      subprocess.run([
                          'openssl', 'rsa',
                          '-in', private_key_path,
                          '-outform', 'PEM',
                          '-pubout',
                          '-out', public_key_path
                      ], check=True, capture_output=True, text=True)

                      logger.info(f"Generated RSA public key for selector: {selector}")

                      # Read private key and clean for SES (remove headers/footers)
                      with open(private_key_path, 'r') as f:
                          private_key_pem = f.read()

                      # AWS Documentation: Remove BEGIN/END lines and line breaks
                      private_key_clean = private_key_pem.replace('-----BEGIN PRIVATE KEY-----', '')
                      private_key_clean = private_key_clean.replace('-----END PRIVATE KEY-----', '')
                      private_key_clean = private_key_clean.replace('\n', '').strip()

                      # Read public key and prepare for DNS TXT record
                      with open(public_key_path, 'r') as f:
                          public_key_pem = f.read()

                      # AWS Documentation: Remove BEGIN/END lines and line breaks for DNS
                      public_key_clean = public_key_pem.replace('-----BEGIN PUBLIC KEY-----', '')
                      public_key_clean = public_key_clean.replace('-----END PUBLIC KEY-----', '')
                      public_key_clean = public_key_clean.replace('\n', '').strip()

                      logger.info(f"AWS Official OpenSSL implementation completed for selector: {selector}")

                      return {
                          'private_key': private_key_clean,
                          'public_key': public_key_clean,
                          'selector': selector
                      }

              except subprocess.CalledProcessError as e:
                  logger.error(f"OpenSSL command failed for {selector}: {str(e)}")
                  raise
              except Exception as e:
                  logger.error(f"RSA key generation failed for {selector}: {str(e)}")
                  raise

          def save_private_key_to_s3(bucket_name, domain, selector, private_key):
              """Save private key to S3 with KMS encryption"""
              try:
                  key_path = f"dkim-keys/{domain}/{selector}/private_key.pem"

                  s3_client.put_object(
                      Bucket=bucket_name,
                      Key=key_path,
                      Body=private_key.encode('utf-8'),
                      ServerSideEncryption='aws:kms',
                      SSEKMSKeyId=os.environ.get('KMS_KEY_ARN'),
                      ContentType='application/x-pem-file'
                  )

                  logger.info(f"Private key saved to S3: s3://{bucket_name}/{key_path}")
                  return key_path

              except Exception as e:
                  logger.error(f"Failed to save private key to S3: {str(e)}")
                  raise

          def save_dns_records_to_s3(bucket_name, domain, dns_records):
              """Save DNS records to S3 for DNSNotifier function"""
              try:
                  # Create timestamp for file name
                  timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
                  key_path = f"dns_records/{domain}/dns_records_{timestamp}.json"

                  # Save DNS records as JSON
                  s3_client.put_object(
                      Bucket=bucket_name,
                      Key=key_path,
                      Body=json.dumps(dns_records, indent=2, ensure_ascii=False).encode('utf-8'),
                      ServerSideEncryption='aws:kms',
                      SSEKMSKeyId=os.environ.get('KMS_KEY_ARN'),
                      ContentType='application/json'
                  )

                  logger.info(f"DNS records saved to S3: s3://{bucket_name}/{key_path}")
                  return key_path

              except Exception as e:
                  logger.error(f"Failed to save DNS records to S3: {str(e)}")
                  raise

          def get_secret_value(secret_arn):
              """Get secret value from AWS Secrets Manager"""
              try:
                  response = secrets_client.get_secret_value(SecretId=secret_arn)
                  return json.loads(response['SecretString'])
              except Exception as e:
                  logger.error(f"Failed to get secret: {str(e)}")
                  raise

          def update_secret_value(secret_arn, config):
              """Update secret value in AWS Secrets Manager"""
              try:
                  secrets_client.update_secret(
                      SecretId=secret_arn,
                      SecretString=json.dumps(config, indent=2, ensure_ascii=False)
                  )
                  logger.info("Secret updated successfully")
              except Exception as e:
                  logger.error(f"Failed to update secret: {str(e)}")
                  raise

          def create_dkim_certificate_aws_official(event):
              """Create DKIM certificate using AWS Official OpenSSL implementation"""
              try:
                  # Get environment variables
                  secret_arn = os.environ.get('DKIM_CONFIG_SECRET_ARN')
                  bucket_name = os.environ.get('CERTIFICATES_BUCKET_NAME')

                  # Get configuration
                  config = get_secret_value(secret_arn)
                  domain = config.get('domain', 'goo.ne.jp')

                  # Get environment for separator generation
                  environment = os.environ.get('ENVIRONMENT', 'prod')

                  # Use existing 'separator' field from configuration first,
                  # then fallback to environment-specific separator
                  dkim_separator = config.get('separator')
                  if not dkim_separator:
                      # Generate environment-specific separator if not in config
                      dkim_separator = os.environ.get('DKIM_SEPARATOR', f'gooid-21-{environment}')
                      logger.info(f"Generated environment-specific separator: {dkim_separator} for environment: {environment}")
                  else:
                      logger.info(f"Using existing separator from config: {dkim_separator}")

                  # Generate selector: DKIMSeparator-yyyymmdd-[1,2,3]
                  current_date = datetime.now().strftime('%Y%m%d')
                  selector_number = event.get('selector_number', '1')  # Default to 1, can be 2 or 3 for rotation

                  # Ensure selector_number is string and valid
                  if selector_number not in ['1', '2', '3']:
                      selector_number = '1'

                  selector = f"{dkim_separator}-{current_date}-{selector_number}"

                  logger.info(f"Creating DKIM certificate for domain: {domain}")
                  logger.info(f"Environment: {environment}")
                  logger.info(f"DKIM Separator: {dkim_separator}")
                  logger.info(f"Generated selector: {selector} (format: {dkim_separator}-{current_date}-{selector_number})")

                  # Generate RSA key pair using AWS Official implementation
                  key_pair = create_rsa_key_pair_aws_official(selector)

                  # Create DNS TXT record
                  dns_record = {
                      'name': f"{selector}._domainkey.{domain}",
                      'type': 'TXT',
                      'value': f"v=DKIM1; k=rsa; p={key_pair['public_key']}",
                      'selector': selector
                  }

                  # Save private key to S3
                  s3_key_path = save_private_key_to_s3(bucket_name, domain, selector, key_pair['private_key'])

                  # Save DNS records for DNSNotifier function (NEW: Fix for DNS notification)
                  save_dns_records_to_s3(bucket_name, domain, [dns_record])

                  # Update configuration (maintain existing structure)
                  validity_days = int(os.environ.get('CERTIFICATE_VALIDITY_DAYS', 365))

                  # Maintain existing selectors array structure
                  existing_selectors = config.get('selectors', [])
                  existing_custom_selectors = config.get('custom_selectors', [])

                  # Add new selector to arrays if not already present
                  if selector not in existing_selectors:
                      existing_selectors.append(selector)
                  if selector not in existing_custom_selectors:
                      existing_custom_selectors.append(selector)

                  config.update({
                      'selector': selector,                          # Current active selector
                      'custom_selector': selector,                   # Current custom selector (compatibility)
                      'selectors': existing_selectors,               # All selectors array
                      'custom_selectors': existing_custom_selectors, # Custom selectors array
                      'dns_record': dns_record,
                      'status': 'certificate_created',
                      'created_at': datetime.utcnow().isoformat(),
                      'expires_at': (datetime.utcnow() + timedelta(days=validity_days)).isoformat(),
                      's3_key_path': s3_key_path,
                      'implementation': 'aws_official_openssl'
                  })

                  # Save updated configuration
                  update_secret_value(secret_arn, config)

                  result = {
                      'statusCode': 200,
                      'message': 'DKIM certificate created successfully using AWS Official OpenSSL implementation',
                      'domain': domain,
                      'selector': selector,
                      'dns_record': dns_record,
                      'implementation': 'aws_official_openssl',
                      's3_key_path': s3_key_path
                  }

                  logger.info(f"DKIM certificate created successfully: {result}")
                  return result

              except Exception as e:
                  logger.error(f"Failed to create DKIM certificate: {str(e)}")
                  raise

          def update_ses_byodkim_automated(event):
              """
              Automated SES BYODKIM Update Implementation
              - Validates DNS TXT record completion
              - Performs 7-step SES update process automatically
              - Comprehensive error handling and rollback
              """
              try:
                  logger.info(f"Starting automated SES BYODKIM update with event: {json.dumps(event, indent=2)}")

                  # Extract parameters
                  domain = event['domain']
                  selector = event['selector']

                  # Prerequisite: DNS TXT Record Validation
                  logger.info(f"Phase 1: Validating DNS TXT record for {selector}._domainkey.{domain}")
                  if not validate_dns_txt_record_completion(domain, selector):
                      return {
                          'statusCode': 400,
                          'error': 'DNS_TXT_NOT_READY',
                          'message': f'DNS TXT record for {selector}._domainkey.{domain} is not yet available. Please wait for DNS propagation.'
                      }

                  logger.info("DNS TXT record validation completed successfully")

                  # Phase 2: Retrieve certificate from S3
                  logger.info("Phase 2: Retrieving DKIM certificate from S3")
                  s3_key = f"dkim-certificates/{domain}/{selector}/private_key.pem"

                  try:
                      response = s3_client.get_object(
                          Bucket=os.environ['DKIM_CERTIFICATES_BUCKET_NAME'],
                          Key=s3_key
                      )
                      private_key_content = response['Body'].read().decode('utf-8')
                      logger.info(f"Successfully retrieved certificate from S3: {s3_key}")
                  except Exception as e:
                      logger.error(f"Failed to retrieve certificate from S3: {str(e)}")
                      return {
                          'statusCode': 404,
                          'error': 'CERTIFICATE_NOT_FOUND',
                          'message': f'Certificate not found at S3 path: {s3_key}'
                      }

                  # Phase 3-9: Execute SES BYODKIM Update Process
                  logger.info("Phase 3: Starting SES BYODKIM update process")

                  try:
                      # Step 1: Check current DKIM configuration
                      logger.info("Step 1: Checking current DKIM configuration")
                      current_config = sesv2_client.get_email_identity_dkim_attributes(EmailIdentity=domain)
                      logger.info(f"Current DKIM status: {current_config.get('DkimAttributes', {}).get('Status', 'Unknown')}")

                      # Step 2: Put DKIM signing attributes with BYODKIM
                      logger.info("Step 2: Updating DKIM signing attributes to BYODKIM")
                      sesv2_client.put_email_identity_dkim_signing_attributes(
                          EmailIdentity=domain,
                          SigningAttributesOrigin='EXTERNAL',
                          SigningAttributes={
                              'DomainSigningSelector': selector,
                              'DomainSigningPrivateKey': private_key_content
                          }
                      )
                      logger.info("Successfully updated DKIM signing attributes")

                      # Step 3: Enable DKIM for the domain
                      logger.info("Step 3: Enabling DKIM for domain")
                      sesv2_client.put_email_identity_dkim_attributes(
                          EmailIdentity=domain,
                          DkimEnabled=True
                      )
                      logger.info("Successfully enabled DKIM")

                      # Step 4: Verify final configuration
                      logger.info("Step 4: Verifying final DKIM configuration")
                      final_config = sesv2_client.get_email_identity_dkim_attributes(EmailIdentity=domain)
                      final_status = final_config.get('DkimAttributes', {})

                      logger.info(f"Final DKIM status: {final_status.get('Status', 'Unknown')}")
                      logger.info(f"Final signing attributes origin: {final_status.get('SigningAttributesOrigin', 'Unknown')}")

                      # Success response
                      result = {
                          'statusCode': 200,
                          'message': 'SES BYODKIM update completed successfully',
                          'domain': domain,
                          'selector': selector,
                          'final_dkim_status': final_status.get('Status'),
                          'signing_origin': final_status.get('SigningAttributesOrigin'),
                          'timestamp': datetime.utcnow().isoformat(),
                          'automation_type': 'lambda_extension'
                      }

                      logger.info(f"SES BYODKIM update completed successfully: {json.dumps(result, indent=2)}")
                      return result

                  except Exception as ses_error:
                      logger.error(f"SES update failed: {str(ses_error)}")

                      # Attempt rollback
                      try:
                          logger.info("Attempting SES configuration rollback")
                          sesv2_client.put_email_identity_dkim_attributes(
                              EmailIdentity=domain,
                              DkimEnabled=False
                          )
                          logger.info("Rollback completed")
                      except Exception as rollback_error:
                          logger.error(f"Rollback failed: {str(rollback_error)}")

                      return {
                          'statusCode': 500,
                          'error': 'SES_UPDATE_FAILED',
                          'message': f'SES BYODKIM update failed: {str(ses_error)}',
                          'rollback_attempted': True
                      }

              except Exception as e:
                  logger.error(f"Automated SES BYODKIM update failed: {str(e)}")
                  return {
                      'statusCode': 500,
                      'error': 'AUTOMATION_FAILED',
                      'message': f'Automated update failed: {str(e)}'
                  }

          def validate_dns_txt_record_completion(domain, selector):
              """
              Validate that DNS TXT record exists using subprocess nslookup
              Returns True if DNS is ready, False otherwise
              """
              try:
                  # Construct DNS query for DKIM TXT record
                  dkim_domain = f"{selector}._domainkey.{domain}"
                  logger.info(f"Querying DNS TXT record using nslookup: {dkim_domain}")

                  # Use nslookup to query DNS TXT record
                  try:
                      result = subprocess.run([
                          'nslookup', '-type=TXT', dkim_domain
                      ], capture_output=True, text=True, timeout=30)

                      if result.returncode == 0:
                          output = result.stdout
                          logger.info(f"nslookup output: {output}")

                          # Basic validation: Check if it's a DKIM record
                          if 'v=DKIM1' in output and 'p=' in output:
                              logger.info("DNS TXT record validation successful")
                              return True
                          else:
                              logger.warning(f"TXT record found but not valid DKIM format for {dkim_domain}")
                              return False
                      else:
                          logger.warning(f"nslookup failed for {dkim_domain}: {result.stderr}")
                          return False

                  except subprocess.TimeoutExpired:
                      logger.warning(f"DNS lookup timeout for {dkim_domain}")
                      return False
                  except Exception as subprocess_error:
                      logger.error(f"Subprocess error during DNS lookup: {str(subprocess_error)}")
                      return False

              except Exception as e:
                  logger.error(f"DNS validation error: {str(e)}")
                  # For safety, if DNS validation fails, don't proceed with SES update
                  return False

      Tags:
        - Key: Name
          Value: !Sub "${ProjectName}-${Environment}-dkim-manager-v2"
        - Key: Project
          Value: !Ref ProjectName
        - Key: Environment
          Value: !Ref Environment

  # Lambda permission for EventBridge
  DKIMManagerInvokePermissionV2:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref DKIMManagerFunctionV2
      Principal: events.amazonaws.com
      SourceArn: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${ProjectName}-${Environment}-*"

  # Lambda permission for SNS (Phase 8 Integration)
  DKIMManagerSNSInvokePermissionV2:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref DKIMManagerFunctionV2
      Principal: sns.amazonaws.com
      SourceArn: !Sub "arn:aws:sns:${AWS::Region}:${AWS::AccountId}:${ProjectName}-${Environment}-certificate-expiring"

Outputs:
  DKIMManagerFunctionArn:
    Description: ARN of the DKIM Manager Lambda function
    Value: !GetAtt DKIMManagerFunctionV2.Arn
    Export:
      Name: !Sub "${ProjectName}-${Environment}-dkim-manager-function-arn"

  DKIMManagerFunctionName:
    Description: Name of the DKIM Manager Lambda function
    Value: !Ref DKIMManagerFunctionV2
    Export:
      Name: !Sub "${ProjectName}-${Environment}-dkim-manager-function-name"

  RenewalAlertDays:
    Description: Alert threshold in days before certificate expiration
    Value: !Ref RenewalAlertDays
    Export:
      Name: !Sub "${ProjectName}-${Environment}-renewal-alert-days"
